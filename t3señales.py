# -*- coding: utf-8 -*-
"""T3Señales

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10kaJPzkxrvB3lrVU6jYDQU-EWrhQEIKk
"""

import numpy as np
import math
import matplotlib.pyplot as plt #Libreria para graficar
#import numpy

def CodificacionPCM(Niveles,NumeroDeBits): #Funcion que convierte los niveles enteros en binarios con el numero de bits especificado
    Texto=""
    Niveles_Bin=[]
    for Dato in Niveles:
        Binario=bin(Dato)
        Binario=Binario[2:]
        if len(Binario)<NumeroDeBits:
            Binario=(NumeroDeBits-len(Binario))*'0'+Binario
        Texto=Texto+Binario+" "
        Niveles_Bin.append(Binario)
    return Texto,Niveles_Bin

Muestras=[] #Lista en la que se almacenan las muestras de la señal
Paso=0.2
for i in range(-20,20):
    Muestras.append(5*math.sin(i*Paso)) #se obtiene una muestra de una función seno
print(len(Muestras))
NumeroDeBits=3 #numeros de bits de cuantización
Niveles=2**NumeroDeBits #numero de niveles de cuantización

Copia=Muestras.copy() #se crea una copia de las muestras para no modificarla
Copia.sort()
Mayor=Copia[len(Muestras)-1]
Menor=Copia[0]
Amplitud=Mayor-Menor #con la mayor y menor amplitud de la señal se calcula el voltaje pico a pico

niveles=[]  #Se crea una lista para almacenar los niveles correspondientes a cada valor de la muestra
for ValorMuestra in Muestras:
    niveles.append(round(((ValorMuestra-Menor)/Amplitud)*(Niveles-1))) #se hace un reescalamiento para que la señal original se encuentre sobre el nivel cero y que su amplitud coinsida con el numero de niveles de cuantizacion
Codigo,Niveles_Bin=CodificacionPCM(niveles, NumeroDeBits) #Se obtiene la representacion binaria de los niveles correspondientes a la señal
print(Codigo)
print(niveles)
print("niveles en binario: ", Niveles_Bin)

x=np.arange(Menor,Mayor,Amplitud/Niveles) #se definen los intervalos de los niveles
print(x)
print("minimo",min)
niveles1=[] #
nivelesCod=[] #
nivelesVolt=[] #

cont=0
for i in x:
  #if cont < len(x):
    #print(i+(Amplitud/(2*Niveles)))
  niveles1.append(i+(Amplitud/(2*Niveles)))
  #cont+=1
print(niveles1)
#print(len(niveles1))
for ValorMuestra in Muestras:
  for nivel in niveles1:
    ErrorCuantizacion=ValorMuestra-nivel
    if abs(ErrorCuantizacion)<=Amplitud/(2*Niveles):
      nivelesCod.append(niveles1.index(nivel))
      nivelesVolt.append(nivel)
      break
print(len(nivelesVolt))
print(nivelesCod)
Codigo,Niveles_Bin=CodificacionPCM(nivelesCod, NumeroDeBits)
print(Codigo)

#plt.figure(figsize=(15,10))
#plt.grid()
#plt.stem(tiempo,nivelesVolt, use_line_collection=True)
#plt.title('niveles de cuantización',fontsize=20)

n=len(Muestras) #Numero de muestras de la señal
tiempo=np.arange(0,1,1/n) #vector de tiempo con el mismo numero de elementos que la muestra

x=np.arange(Menor,Mayor,Amplitud/Niveles) #se definen los intervalos de los niveles
print(x)
niveles1=[] #
nivelesCod=[] #
nivelesVolt=[] #

cont=0
for i in x:
  #if cont < len(x):
    #print(i+(Amplitud/(2*Niveles)))
  niveles1.append(i+(Amplitud/(2*Niveles)))
  #cont+=1
print(niveles1)
#print(len(niveles1))

for ValorMuestra in Muestras:
  posicion=0
  valor=Mayor+1
  contador=0
  for nivel in niveles1:
    ErrorCuantizacion=abs(ValorMuestra-nivel)
    if ErrorCuantizacion<valor:
        valor=ErrorCuantizacion
        posicion=niveles1.index(nivel)
  nivelesCod.append(posicion)
  nivelesVolt.append(niveles1[posicion])
    #if abs(ErrorCuantizacion)<=Amplitud/(2*Niveles):
     # nivelesCod.append(niveles1.index(nivel))
      #nivelesVolt.append(nivel)
      #break
print(len(nivelesVolt))
print(nivelesCod)
Codigo,Niveles_Bin=CodificacionPCM(nivelesCod, NumeroDeBits)
print(Codigo)

#Se grafican los datos btenidos
plt.figure(figsize=(15,20))
plt.subplot(311)
plt.grid()
plt.plot(tiempo,Muestras,label='Señal original')
plt.title('Señal original',fontsize=20)

plt.subplot(312)
plt.grid()
plt.plot(tiempo,nivelesVolt,label='Señal muestreada')
plt.title('Señal muestreada',fontsize=20)

plt.subplot(313)
plt.grid()
plt.stem(tiempo,nivelesVolt, use_line_collection=True)
plt.title('niveles de cuantización',fontsize=20)

def LlenarMuestras(Lista): #Se implementa una función y un númeor de muestras para llenar
    NumeroDeMuestras=0
    FrecuenciaMaxima=1000
    FrecuenciaDeMuestreo=10*FrecuenciaMaxima
    Ts=1/FrecuenciaDeMuestreo
    A=3 #Amplitud
    #Funcion
    t=0
    VectorTiempo=[]
    while t<=0.05:
        Lista.append(A*math.sin(2*np.pi*FrecuenciaMaxima*t))
        NumeroDeMuestras+=1
        t+=Ts
        VectorTiempo.append(t)
    return VectorTiempo


#DPCM

MuestrasDPCM=[]
VectorTiempoDPCM=LlenarMuestras(MuestrasDPCM)
plt.figure(figsize=(15,15))
plt.grid()
plt.plot(VectorTiempoDPCM,MuestrasDPCM)
plt.title('Señal Ejemplo DPCM',fontsize=20)

def LlenarMuestras(Lista): #Se implementa una función y un númeor de muestras para llenar
    NumeroDeMuestras=0
    FrecuenciaMaxima=1000
    FrecuenciaDeMuestreo=20*FrecuenciaMaxima
    Ts=1/FrecuenciaDeMuestreo
    A=5 #Amplitud
    #Funcion
    t=0
    VectorTiempo=[]
    while t<=0.005:
        Lista.append(A*math.sin(2*np.pi*FrecuenciaMaxima*t))
        NumeroDeMuestras+=1
        VectorTiempo.append(t)
        t+=Ts
    return VectorTiempo

def Correlaciones(Lista, Cantidad): #Retorna lista de Rxx(ks)
    ListaCorrelaciones=[]
    for Numero in range(Cantidad):
        Suma=0
        for Elemento in Lista:
            if Lista.index(Elemento)+Numero<len(Lista):
                Suma+=Elemento*Lista[Lista.index(Elemento)+Numero]
        Suma=Suma/len(Lista)
        ListaCorrelaciones.append(Suma)
    return ListaCorrelaciones

#DPCM
NumeroCorrelaciones=4
MuestrasDPCM=[]
VectorTiempoDPCM=LlenarMuestras(MuestrasDPCM)
ListaCorrelaciones=Correlaciones(MuestrasDPCM, NumeroCorrelaciones)

if NumeroCorrelaciones == 4:
  listaMa=[[ListaCorrelaciones[0],ListaCorrelaciones[1],ListaCorrelaciones[2]],[ListaCorrelaciones[1],ListaCorrelaciones[0],ListaCorrelaciones[1]],[ListaCorrelaciones[2],ListaCorrelaciones[1],ListaCorrelaciones[0]]]
  A=np.array(listaMa)
  print(A)
  #B=np.linalg.inv(A)
  InvA=np.linalg.inv(A)
  #print(InvA)
  B = np.array([ListaCorrelaciones[1], ListaCorrelaciones[2],ListaCorrelaciones[3]])
  print(B)
  X = np.linalg.inv(A).dot(B)
  #X = InvA.dot(B)

print(X)

from random import randint

def ASCII(text):
    ascii_values = [ord(character) for character in text]
    return ascii_values

def Binario(Lista):
    #Estandarizado a 8 bits para tildes y más
    Texto=""
    for ASCII in Lista:
        Bin=bin(ASCII)[2:]
        if len(Bin)<8:
            Bin="0"*(8-len(Bin))+Bin
        Texto=Texto+ Bin #Siempre serán positivos por ASCII
    long=len(Texto)
    print(Texto)
    return Texto

def Particion(Texto, Rango, Extra):
    Bloques=[]
    if Extra!=0: #Se busca agregar ceros al último bloque si no es multiplo del rango
        Final=Texto[len(Texto)-Extra:]
        TextoTemp=Texto[:len(Texto)-Extra]+"0"*Extra+Final
    else:
        TextoTemp=Texto
    while len(TextoTemp)!=0:
        Bloques.append(TextoTemp[:Rango])
        TextoTemp=TextoTemp[Rango:]
    #print("bloques :",Bloques,": fin")
    return Bloques

def Repeticion(TextoBinario, Redundancia, Bloque):
    #Bloque es la cantidad de bits que se enviaran por ¿codigo?
    #Redundancia es la cantidad de veces que un bloque será repetido
    #Se implementa una funcion que simule ruido

    Codigo=""
    Extra=len(TextoBinario)%Bloque
    Inverso=100 #Inverso de la probabilidad de error
    TextoBinarioCopia=""

    Bloques=Particion(TextoBinario,Bloque, Extra)
    for Parte in Bloques:
        #Simulacion de ruido
        #Inverso=100 #Inverso de la probabilidad de error
        CodigoConRuido=""
        for _ in range(Redundancia):
            if(randint(1, Inverso)==Inverso):
                Maximo=len(Parte)-1
                Pos=randint(0,Maximo)
                Antes=Parte[:Pos]
                Despues=Parte[Pos+1:]
                if Parte[Pos]=="1":
                    Ruido=Antes+"0"+Despues
                else:
                    Ruido=Antes+"1"+Despues
                CodigoConRuido=CodigoConRuido+Ruido
            else:
                CodigoConRuido=CodigoConRuido+Parte
        Codigo=Codigo+CodigoConRuido #Con Ruido
    return Codigo

def DecodificacionRepeticion(Codigo, Redundacia, Bloque):
    Texto=""
    Binario=""
    ASCII=[]
    CopiaCodigo=Codigo
    while len(CopiaCodigo)!=0:
        Fragmento=CopiaCodigo[:Bloque*Redundacia]
        CopiaCodigo=CopiaCodigo[Bloque*Redundacia:]

        Bloques=Particion(Fragmento, Bloque, 0)
        Cantidad=0
        Maximo=""
        for Parte in Bloques:
            Contado=Bloques.count(Parte)
            if(Cantidad<Contado):
                Cantidad=Contado
                Maximo=Parte
        #Unos=Bloques.count("1")
        #Ceros=Bloques.count("0")
        #if Unos>Ceros:
        #    Maximo="1"
        #else:
        #    Maximo="0"
        Binario= Binario + Maximo
    for Fragmento in Particion(Binario,8,0):
        Numero=int(Fragmento,2)
        Texto=Texto+chr(Numero)
        ASCII.append(Numero)
    return Texto

def NumeroDeErrores(TextoOriginal, Final):
    Numero=0
    if(len(TextoOriginal)==len(Final)):
        for Pos in range(len(TextoOriginal)):
            if(TextoOriginal[Pos]!=Final[Pos]):
                Numero+=1
    return Numero

def Prueba():
    Texto="""Hemos perdido aun este crepúsculo.
Nadie nos vio esta tarde con las manos unidas
mientras la noche azul caía sobre el mundo.

He visto desde mi ventana
la fiesta del poniente en los cerros lejanos.

A veces como una moneda
se encendía un pedazo de sol entre mis manos.

Yo te recordaba con el alma apretada
de esa tristeza que tú me conoces.

Entonces, dónde estabas?
Entre qué gentes?
Diciendo qué palabras?
Por qué se me vendrá todo el amor de golpe
cuando me siento triste, y te siento lejana?

Cayó el libro que siempre se toma en el crepúsculo,
y como un perro herido rodó a mis pies mi capa.

Siempre, siempre te alejas en las tardes
hacia donde el crepúsculo corre borrando estatuas."""
    TextoASCII=ASCII(Texto)
    TextoASCIIBin=Binario(TextoASCII)

    for BloqueDeBits in range(1,7):
        for Veces in range(1,8,2):
            CodigoRepeticion=Repeticion(TextoASCIIBin, Veces, BloqueDeBits)
            Decodificado=DecodificacionRepeticion(CodigoRepeticion, Veces, BloqueDeBits)
            print("Redundancia:", Veces, " a Bloques de: ", BloqueDeBits, "con ",NumeroDeErrores(Texto, Decodificado), " errores")
            if Decodificado==Texto:
                print("Sin errores")
                #print(Decodificado)
            else:
                print("Con errores")
                #print(Decodificado)



Texto="""Hemos perdido aun este crepúsculo.
Nadie nos vio esta tarde con las manos unidas
mientras la noche azul caía sobre el mundo.

He visto desde mi ventana
la fiesta del poniente en los cerros lejanos.

A veces como una moneda
se encendía un pedazo de sol entre mis manos.

Yo te recordaba con el alma apretada
de esa tristeza que tú me conoces.

Entonces, dónde estabas?
Entre qué gentes?
Diciendo qué palabras?
Por qué se me vendrá todo el amor de golpe
cuando me siento triste, y te siento lejana?

Cayó el libro que siempre se toma en el crepúsculo,
y como un perro herido rodó a mis pies mi capa.

Siempre, siempre te alejas en las tardes
hacia donde el crepúsculo corre borrando estatuas."""
TextoASCII=ASCII(Texto)
TextoASCIIBin=Binario(TextoASCII)
Veces = 7
BloqueDeBits = 1

CodigoRepeticion=Repeticion(TextoASCIIBin, Veces, BloqueDeBits)

Decodificado=DecodificacionRepeticion(CodigoRepeticion, Veces, BloqueDeBits)

Prueba()

#print(Decodificado)

Matriz=[1,1,1,1,1,1,1]
print(1*int(Matriz))